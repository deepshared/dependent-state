{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE UndecidableInstances   #-}

module Control.Monad.State.Dependent where

-- import Prologue
--
-- import           Control.Monad.State
-- import qualified Control.Monad.Catch (MonadMask, MonadCatch, MonadThrow)
-- import           Control.Monad.Fix
-- import           Control.Monad.Primitive
--
--
-- newtype FooT m a = FooT (StateT Int m a)
--
-- instance IsState FooT -- where state = wrapped'
--
-- instance MonadState (FooT m a)
--
--
-- -- === Types and classes ===
--
-- -- type    State  s     = StateT t s Identity
-- -- newtype StateT s m a = StateT (State.StateT s m a)
-- --                        deriving ( Functor, Monad, Applicative, MonadIO, MonadPlus, MonadTrans, Alternative
-- --                                 , MonadFix, MonadMask, MonadCatch, MonadThrow)
-- --
-- -- makeWrapped ''StateT
--
-- type family StateData t
-- type instance StateData (StateT s m a) = s
--
-- class IsStateT t where
--     stateT :: forall m a. Iso' (t m a) (StateT (StateData t) m a)
--
-- class MonadState t s m | t m -> s where
--     get :: m s
--     put :: s -> m ()
--
--
-- -- Basic instances
--
-- instance {-# OVERLAPPABLE #-} (Monad m, s ~ s') => MonadGet t s (StateT t s' m) where get _ = StateT State.get   ; {-# INLINE get #-}
-- instance {-# OVERLAPPABLE #-} (Monad m, s ~ s') => MonadPut t s (StateT t s' m) where put _ = StateT . State.put ; {-# INLINE put #-}
--
-- instance State.MonadState r m => State.MonadState r (StateT t s m) where
--     get = StateT (lift State.get)   ; {-# INLINE get #-}
--     put = StateT . lift . State.put ; {-# INLINE put #-}
--
-- instance {-# OVERLAPPABLE #-} (MonadGet tp s m, MonadTrans t, Monad (t m)) => MonadGet tp s (t m) where get = lift .  get ; {-# INLINE get #-}
-- instance {-# OVERLAPPABLE #-} (MonadPut tp s m, MonadTrans t, Monad (t m)) => MonadPut tp s (t m) where put = lift .: put ; {-# INLINE put #-}
--
-- -- Primitive
-- instance PrimMonad m => PrimMonad (StateT t s m) where
--     type PrimState (StateT t s m) = PrimState m
--     primitive = lift . primitive ; {-# INLINE primitive #-}
--
--
-- -- === Utilities ===
--
-- runT  :: IsStateT t => t m a -> s -> m (a, s)
-- evalT :: IsStateT t => t m a -> s -> m a
-- execT :: IsStateT t => t m a -> s -> m s
--
-- runT  _ = State.runStateT  . view StateT ; {-# INLINE runT  #-}
-- evalT _ = State.evalStateT . view StateT ; {-# INLINE evalT #-}
-- execT _ = State.execStateT . view StateT ; {-# INLINE execT #-}
--
-- run  :: IsState t => t a -> s -> (a, s)
-- eval :: IsState t => t a -> s -> a
-- exec :: IsState t => t a -> s -> s
--
-- run   = runIdentity .:. runT  ; {-# INLINE run  #-}
-- eval  = runIdentity .:. evalT ; {-# INLINE eval #-}
-- exec  = runIdentity .:. execT ; {-# INLINE exec #-}
--
-- with :: MonadState t s m => t -> (s -> s) -> m a -> m a
-- with t f m = do
--     s <- get t
--     put t $ f s
--     out <- m
--     put t s
--     return out
-- {-# INLINE with #-}
--
-- modify :: MonadState t s m => t -> (s -> (s, a)) -> m a
-- modify t = modifyM t . fmap return
-- {-# INLINE modify #-}
--
-- modify_ :: MonadState t s m => t -> (s -> s) -> m ()
-- modify_ t = modify t . fmap (,())
-- {-# INLINE modify_ #-}
--
-- modifyM :: MonadState t s m => t -> (s -> m (s, a)) -> m a
-- modifyM t f = do
--     s <- get t
--     (s', a) <- f s
--     put t $ s'
--     return a
-- {-# INLINE modifyM #-}
--
-- withState :: MonadState t s m => t -> (s -> s) -> m ()
-- withState t f = do
--     s <- get t
--     put t (f s)
-- {-# INLINE withState #-}
